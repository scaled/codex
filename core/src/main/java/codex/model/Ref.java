//
// Codex - a framework for grokking code
// http://github.com/scaled/codex/blob/master/LICENSE

package codex.model;

import codex.store.ProjectStore;

/**
 * Uniquely identifies a def. This comes in two flavors: a local ref, used within a project to
 * reference other defs in that same project, and a global ref, used to reference defs in other
 * projects.
 */
public abstract class Ref {

  /** Represents a def within a known project. */
  public static final class Local extends Ref {

    /** The project in which this def originates. */
    public final ProjectStore project;

    /** The integer id of the def in the project. */
    public final Long defId;

    public boolean equals (Local other) {
      return project == other.project && defId.equals(other.defId);
    }

    @Override public int hashCode () {
      return project.hashCode() ^ defId.intValue();
    }

    @Override public boolean equals (Object other) {
      return (other instanceof Local) && equals((Local)other);
    }

    @Override public String toString () {
      return project + ":" + defId;
    }

    private Local (ProjectStore project, Long defId) {
      this.project = project;
      this.defId = defId;
    }
  }

  /** Represents a def in any project. */
  public static final class Global extends Ref {

    /** The root global name. */
    public static final Global ROOT = new Global(null, null);

    /** Parses a string generated by {@link #toString}. */
    public static Global fromString (String ref) {
      return fromString(ROOT, ref);
    }

    /** The parent component of this id. */
    public final Global parent;

    /** The simple identifier for this component of the id. An interned string. */
    public final String id;

    /** Returns a global id with {@code this} as its parent and {@code id} as its leaf. */
    public Global plus (String id) {
      return new Global(this, id);
    }

    @Override public int hashCode () {
      return id.hashCode() ^ (parent == ROOT ? 13 : parent.hashCode());
    }

    @Override public boolean equals (Object other) {
      return (other instanceof Global) && equals((Global)other);
    }

    @Override public String toString () {
      StringBuilder sb = new StringBuilder();
      toString(sb);
      return sb.toString();
    }

    private void toString (StringBuilder sb) {
      if (parent != ROOT) {
        parent.toString(sb);
        sb.append(" ");
      }
      sb.append(id);
    }

    private boolean equals (Global other) {
      // TODO: intern whole global instances and compare by reference?
      return id == other.id && (parent == other.parent || parent.equals(other.parent));
    }

    private Global (Global parent, String id) {
      this.parent = parent;
      this.id = (id == null) ? null : id.intern();
    }

    private static Global fromString (Global parent, String rest) {
      int sidx = rest.indexOf(" ");
      if (sidx == -1) return parent.plus(rest);
      else return fromString(parent.plus(rest.substring(0, sidx)), rest.substring(sidx+1));
    }
  }

  /** Returns a local id for the specified def in the specified project. */
  public static Ref local (ProjectStore project, Long defId) {
    return new Local(project, defId);
  }

  /** Returns a global ref for the specified (outer- to inner-most) name path. */
  public static Ref global (String... names) {
    Ref.Global ref = Ref.Global.ROOT;
    for (String name : names) ref = ref.plus(name);
    return ref;
  }

  private Ref () {} // prevent other subclasses
}
